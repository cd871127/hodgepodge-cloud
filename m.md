[toc]

# JAVA基础

### 多线程

`Thread.start()`只能执行一次，第二次执行会抛出异常

`Thread.run()`独立调用的时候是普通方法

守护线程不影响虚拟机停机

竞态Race condition：计算结果正确性与时间有关

除了long，double其他的基本类型的写操作都是原子操作

volatile修饰的变量的写操作是原子的

缓存同步解决不可见

JLS 保证父线程在启动子线程之前对共享变量的更新对于子线程是可见的

线程终止后，对共享变量的修改对于调用该线程的join方法的线程是可见的

synchronized 内部锁 非公平 同步快异常也会正常释放锁

可重入锁：一个线程持有锁还能再次申请成功这个锁

公平锁：适合长任务，保证任务能够执行
非公平锁：适合短任务，提高吞吐量

排他锁：`ReentrantLock`

读写锁：`ReadWriteLock`普通读写锁,`ReentrantReadWriteLock`可以在拥有写锁的同时申请读锁，就是锁的降级

内存屏障：针对内存读写的指令，防止重排序，实现刷新缓存
可见性划分：加载屏障，存储屏障
有序性划分：获取屏障，释放屏障

volatile:保障可见性，有序性，保障long，double读写原子性，如果修饰的为变量，那么只影响变量引用

读，写volatile会产生类似获取，释放锁的效果，会有屏障所以保障可见和有序，不会引起上下文切换

双重检查锁定如果没有volatile，可能引重排序导致问题

对象发布

对象逸出，在构造器把this给出去，有可能构造函数未执行完成

static能保证第一次读取的是初始值，如果是对象，那么是已经初始化完成的

对象发布到其他线程时，该对象所有final字段都是初始化完成的

决定多线程提速的关键是串行的部分



### 套接字

### nio

#### netty

### 集合类

# 中间件

### mysql

### redis

### rabbitmq

### mongodb

### docker

# 设计模式

https://www.cnblogs.com/pony1223/p/7608955.html

### 创建型模式

##### 工厂方法

优点：非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统
缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加

### 结构型模式

##### 适配器模式
类适配器
对象适配器
接口适配器
优点：
缺点：

### 行为型模式

##### 状态模式

场景：行为依赖于它的一个或者多个变化的属性，状态变化导致行为变化，不能用行为影响状态
优点：在状态模式中我们可以减少大块的if…else语句，它是允许态转换逻辑与状态对象合成一体
缺点：增加系统中类或者对象的个数。

行为在状态中实现

# 算法

### 基础数据结构

### 树

### 高级算法

#### 动态规划

#### 贪心算法

# 框架

### spring boot

### mybatis

### 

